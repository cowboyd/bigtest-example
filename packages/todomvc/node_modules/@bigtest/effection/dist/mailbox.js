"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const effection_1 = require("effection");
const events_1 = require("events");
const pattern_1 = require("./pattern");
var pattern_2 = require("./pattern");
exports.any = pattern_2.any;
const suspend_1 = require("./suspend");
const ensure_1 = require("./ensure");
function isEventTarget(target) { return typeof target.addEventListener === 'function'; }
// eslint-disable-next-line @typescript-eslint/no-explicit-any
class Mailbox {
    constructor() {
        this.subscriptions = new events_1.EventEmitter();
        this.messages = new Set();
    }
    static *subscribe(emitter, events) {
        let mailbox = new Mailbox();
        yield suspend_1.suspend(effection_1.monitor(subscribe(mailbox, emitter, events)));
        return mailbox;
    }
    send(message) {
        this.messages.add(message);
        this.subscriptions.emit('message', message);
    }
    receive(pattern = undefined) {
        let match = pattern_1.compile(pattern);
        return ({ resume, ensure }) => {
            let dispatch = (message) => {
                if (this.messages.has(message) && match(message)) {
                    this.messages.delete(message);
                    resume(message);
                    return true;
                }
            };
            for (let message of this.messages) {
                if (dispatch(message)) {
                    return;
                }
                ;
            }
            this.subscriptions.on('message', dispatch);
            ensure(() => this.subscriptions.off('message', dispatch));
        };
    }
    *pipe(other) {
        let that = this; // eslint-disable-line @typescript-eslint/no-this-alias
        yield suspend_1.suspend(effection_1.monitor(function* () {
            while (true) {
                let message = yield that.receive();
                other.send(message);
            }
        }));
    }
    *map(fn) {
        let that = this; // eslint-disable-line @typescript-eslint/no-this-alias
        let other = new Mailbox();
        yield suspend_1.suspend(effection_1.monitor(function* () {
            while (true) {
                let message = yield that.receive();
                other.send(fn(message));
            }
        }));
        return other;
    }
}
exports.Mailbox = Mailbox;
function* subscribe(mailbox, emitter, events) {
    for (let name of [].concat(events)) {
        let listener = (...args) => {
            mailbox.send({ event: name, args });
        };
        if (isEventTarget(emitter)) {
            emitter.addEventListener(name, listener);
            yield suspend_1.suspend(ensure_1.ensure(() => emitter.removeEventListener(name, listener)));
        }
        else {
            emitter.on(name, listener);
            yield suspend_1.suspend(ensure_1.ensure(() => emitter.off(name, listener)));
        }
    }
}
exports.subscribe = subscribe;
//# sourceMappingURL=mailbox.js.map